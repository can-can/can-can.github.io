---
layout: post
title: 客户端调用失败几种原因
categories: zh
category: zh
tag: Availability

---

# 前言

在提供RPC和后端服务时，我最关注的还是客户端（这里说的是服务器作为调用方）的成功率。因为QPS很高，随便一点波动都会产生很高的失败数。

这里我总结一下我工作中遇到的会降低客户端成功率的原因。

在处理结果正确的前提下，失败率上涨，直接原因有两种：

1. 一种是服务的处理时间过长，
2. 一种是服务处理时间正常，但是因为服务器和客户端之间的传输有问题而导致客户端失败。

# 服务处理时间过长

服务器处理时间过长一般有以下一种情况。

## 应用没有预热

一般应用会依赖Cache、DB、RPC，还有有依赖Hystrix等组件。像Hystrix线程池和Tair客户端对服务端的连接都是懒加载，当第一波请求过来的时候，它们要先初始化自己。这就导致了第一波流量很容易超时。

### 解决方案

对于这个问题，我现在有两种方法：

1. 接入流量从小到大递增，这样可以将第一波超时的请求量减小
2. 取消懒加载，尽量初始化更多的资源。但是想Hystrix和Tair这些组件没有提供取消懒加载的方法。从组件方面入手，只能取消一部分的懒加载。

还有一种方法，比较麻烦，需要有对应的基础设施。当应用启动后，从线上复制一份真实流量过来，用来预热应用。

## 依赖异常

emmm。应用依赖的服务部是100%可用，特别是RPC和Cache。如果不做一些措施，它们对服务稳定性的影响很大。

### 解决方案

一般的解决方案是将依赖隔离和降级。

但是当Cache不可用时，对服务响应时间的影响还是巨大的。所以我最近的一个方案是在隔离的基础上进行多数据源并发读取，谁先来用谁的。

## GC停顿时间过长

我用的G1 GC，现在遇到的问题是Ref Pro时间太长。

``-XX:+ParallelRefProcEnabled``是个不错的选择

参考：https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74

虽然是JDK 9的文档，不过我查了一下，这个参数JDK7、8的G1 GC都有

## CPU异常

### CPU.steal过高

因为现在大多机器都是虚拟机，所以要和其他虚拟机共享CPU。当 CPU.steal过高的时候，会影响我们的CPU时间。

CPU.steal问题可以参考:http://blog.scoutapp.com/articles/2013/07/25/understanding-cpu-steal-time-when-should-you-be-worried

## Swap高

Swap高的确会服务异常，但是导致SWAP高的原因，就需要有针对行的去查了。



# 传输问题

当客户端失败率上升，但是服务端统计的响应时间并没有上升，那么很有可能是传输问题。现在客户端和服务端基本都是TCP连接，所以大概率是TCP问题，但是没具体分析。

